/// <reference path="../../pb_data/types.d.ts" />

/**
 * PocketPages configuration with official plugins inlined
 * Sources:
 * - pocketpages-plugin-js-sdk@0.2.0/dist/index.js
 * - pocketpages-plugin-auth@0.2.2/dist/index.js
 *
 * This file is auto-generated by scripts/package-plugins.js during 'bun install'
 * Do not edit manually - changes will be overwritten on next install
 */

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __copyProps = (to, from, except, desc) => {
	if (from && typeof from === "object" || typeof from === "function") for (var keys = __getOwnPropNames(from), i = 0, n = keys.length, key; i < n; i++) {
		key = keys[i];
		if (!__hasOwnProp.call(to, key) && key !== except) __defProp(to, key, {
			get: ((k) => from[k]).bind(null, key),
			enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable
		});
	}
	return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", {
	value: mod,
	enumerable: true
}) : target, mod));


const pocketbase_js_sdk_jsvm = __toESM(require("pocketbase-js-sdk-jsvm"));


const jsSdkPluginFactory = (config, extra) => {
	const { globalApi } = config;
	const { dbg } = globalApi;
	const newClient = (host, auth, authToken) => {
		const pb = new pocketbase_js_sdk_jsvm.default(host);
		if (auth) {
			dbg(`auth`, typeof auth, auth);
			const token = authToken ?? auth.newAuthToken();
			pb.authStore.save(token, JSON.parse(JSON.stringify(auth)));
			dbg(`created new PocketBase client for ${host} with saved auth: ${auth.id} ${token}`);
		} else dbg(`created new PocketBase client for ${host}`);
		return pb;
	};
	const pbCache = /* @__PURE__ */ new Map();
	globalApi.pb = (options) => {
		const host = options?.host ?? extra?.host ?? `http://localhost:8090`;
		const auth = options?.auth ?? options?.request?.auth;
		const authToken = options?.request?.authToken;
		const key = `${host}-${auth?.id}`;
		if (pbCache.has(key)) return pbCache.get(key);
		dbg(`creating new pb client for ${key}`);
		const pb = newClient(host, auth, authToken);
		pbCache.set(key, pb);
		return pb;
	};
	return { name: "js-sdk" };
};
var src_default = jsSdkPluginFactory;

const safeParseJson = (value) => {
	if (!value) return value;
	try {
		return JSON.parse(value);
	} catch {
		return value;
	}
};
const toPlainObject = (value) => {
	if (typeof value === "object" && value !== null) return JSON.parse(JSON.stringify(value));
	return value;
};
const authPluginFactory = (config) => {
	const { globalApi } = config;
	const { dbg, info } = globalApi;
	globalApi.createUser = (email, password, options) => {
		if (!email.trim()) throw new Error("Email is required");
		if (!password.trim()) throw new Error("Password is required");
		const pb = globalApi.pb();
		const user = pb.collection(options?.collection ?? "users").create({
			email,
			password,
			passwordConfirm: password
		});
		dbg(`created user: ${user.id}`);
		if (options?.sendVerificationEmail === void 0 || options.sendVerificationEmail) globalApi.requestVerification(email, options);
		return user;
	};
	globalApi.createAnonymousUser = (options) => {
		const email = `anonymous-${$security.randomStringWithAlphabet(10, "123456789")}@example.com`;
		return {
			email,
			...globalApi.createPaswordlessUser(email, {
				...options,
				sendVerificationEmail: false
			})
		};
	};
	globalApi.createPaswordlessUser = (email, options) => {
		const password = $security.randomStringWithAlphabet(40, "123456789");
		dbg(`created paswordless user: ${email}:${password}`);
		return {
			password,
			user: globalApi.createUser(email, password, options)
		};
	};
	globalApi.requestVerification = (email, options) => {
		const pb = globalApi.pb();
		pb.collection(options?.collection ?? "users").requestVerification(email);
	};
	globalApi.confirmVerification = (token, options) => {
		const pb = globalApi.pb();
		pb.collection(options?.collection ?? "users").confirmVerification(token);
	};
	globalApi.requestOTP = (email, options) => {
		const pb = globalApi.pb();
		try {
			const { user, password } = globalApi.createPaswordlessUser(email, {
				sendVerificationEmail: false,
				...options
			});
		} catch (e) {}
		const res = pb.collection(options?.collection ?? "users").requestOTP(email);
		return res;
	};
	return {
		name: "auth",
		onRequest: ({ request, response }) => {
			const { auth } = request;
			if (auth) {
				dbg(`skipping cookie auth because auth record already set: ${auth.id}`);
				return;
			}
			/**
			* If the route is protected, check the auth
			*/
			const cookieRecordAuth = safeParseJson(request.cookies("pb_auth"));
			if (typeof cookieRecordAuth !== "object") {
				dbg(`invalid auth cookie found in cookie: ${cookieRecordAuth}`);
				response.cookie("pb_auth", "");
				return;
			}
			if (cookieRecordAuth?.token) try {
				const validAuthRecord = $app.findAuthRecordByToken(cookieRecordAuth.token);
				if (!validAuthRecord) {
					dbg(`invalid auth token found in cookie: ${cookieRecordAuth.token}`);
					response.cookie("pb_auth", "");
					return;
				}
				$apis.enrichRecord(request.event, validAuthRecord);
				request.auth = validAuthRecord;
				request.authToken = cookieRecordAuth.token;
			} catch (e) {
				dbg(`error fetching auth record: ${e}`);
			}
		},
		onExtendContextApi: ({ api }) => {
			const pb = () => api.pb();
			api.registerWithPassword = (email, password, options) => {
				api.createUser(email, password, options);
				const authData = api.signInWithPassword(email, password, options);
				return authData;
			};
			api.signInWithPassword = (email, password, options) => {
				const authData = pb().collection(options?.collection ?? "users").authWithPassword(email, password);
				api.signIn(authData);
				return authData;
			};
			api.signInAnonymously = (options) => {
				const { user, email, password } = api.createAnonymousUser();
				const authData = api.signInWithPassword(email, password, options);
				return authData;
			};
			api.signInWithOTP = (otpId, password, options) => {
				const authData = pb().collection(options?.collection ?? "users").authWithOTP(otpId, password.toString());
				api.signIn(authData);
				return authData;
			};
			api.requestOAuth2Login = (providerName, options) => {
				const methods = pb().collection(options?.collection ?? "users").listAuthMethods();
				const { providers } = methods.oauth2;
				const provider = providers.find((p) => p.name === providerName);
				if (!provider) throw new Error(`Provider ${providerName} not found`);
				const redirectUrl = `${$app.settings().meta.appURL}${options?.redirectPath ?? "/auth/oauth/confirm"}`;
				const authUrl = provider.authURL + redirectUrl;
				api.response.cookie(options?.cookieName ?? "pp_oauth_state", {
					...api.pick(provider, "name", "state", "codeChallenge", "codeVerifier"),
					redirectUrl
				});
				if (options?.autoRedirect ?? true) api.response.redirect(authUrl);
				return authUrl;
			};
			api.signInWithOAuth2 = (state, code, options, _storedProviderInfo) => {
				const storedProvider = _storedProviderInfo ?? api.request.cookies(options?.cookieName ?? "pp_oauth_state");
				if (!storedProvider) throw new Error("No stored provider info found");
				if (storedProvider.state !== state) throw new Error(`State parameters don't match.`);
				const authData = pb().collection(options?.collection ?? "users").authWithOAuth2Code(storedProvider.name, code, storedProvider.codeVerifier, storedProvider.redirectUrl, { emailVisibility: false });
				api.signIn(authData);
				return authData;
			};
			api.signOut = () => {
				api.response.cookie(`pb_auth`, "");
			};
			api.signIn = (authData) => {
				const { record, token } = authData;
				if (!record) throw new Error("No auth record found");
				dbg(`signing in with token and saving to pb_auth cookie: ${record.id} ${token}`);
				api.response.cookie(`pb_auth`, {
					token,
					record: toPlainObject(record)
				});
			};
		}
	};
};
var src_default = authPluginFactory;

module.exports = {
  plugins: [
    jsSdkPluginFactory,
    authPluginFactory
  ],
  debug: false
};
