/// <reference path="../../pb_data/types.d.ts" />

/**
 * PocketPages configuration with official auth plugin code inlined
 * Source: pocketpages-plugin-auth@0.2.2/dist/index.js
 *
 * This file is auto-generated by scripts/prepare-auth.js during 'bun install'
 * Do not edit manually - changes will be overwritten on next install
 */

const safeParseJson = (value) => {
	if (!value) return value;
	try {
		return JSON.parse(value);
	} catch {
		return value;
	}
};
const toPlainObject = (value) => {
	if (typeof value === "object" && value !== null) return JSON.parse(JSON.stringify(value));
	return value;
};
const authPluginFactory = (config) => {
	const { globalApi } = config;
	const { dbg, info } = globalApi;
	globalApi.createUser = (email, password, options) => {
		if (!email.trim()) throw new Error("Email is required");
		if (!password.trim()) throw new Error("Password is required");
		const pb = globalApi.pb();
		const user = pb.collection(options?.collection ?? "users").create({
			email,
			password,
			passwordConfirm: password
		});
		dbg(`created user: ${user.id}`);
		if (options?.sendVerificationEmail === void 0 || options.sendVerificationEmail) globalApi.requestVerification(email, options);
		return user;
	};
	globalApi.createAnonymousUser = (options) => {
		const email = `anonymous-${$security.randomStringWithAlphabet(10, "123456789")}@example.com`;
		return {
			email,
			...globalApi.createPaswordlessUser(email, {
				...options,
				sendVerificationEmail: false
			})
		};
	};
	globalApi.createPaswordlessUser = (email, options) => {
		const password = $security.randomStringWithAlphabet(40, "123456789");
		dbg(`created paswordless user: ${email}:${password}`);
		return {
			password,
			user: globalApi.createUser(email, password, options)
		};
	};
	globalApi.requestVerification = (email, options) => {
		const pb = globalApi.pb();
		pb.collection(options?.collection ?? "users").requestVerification(email);
	};
	globalApi.confirmVerification = (token, options) => {
		const pb = globalApi.pb();
		pb.collection(options?.collection ?? "users").confirmVerification(token);
	};
	globalApi.requestOTP = (email, options) => {
		const pb = globalApi.pb();
		try {
			const { user, password } = globalApi.createPaswordlessUser(email, {
				sendVerificationEmail: false,
				...options
			});
		} catch (e) {}
		const res = pb.collection(options?.collection ?? "users").requestOTP(email);
		return res;
	};
	return {
		name: "auth",
		onRequest: ({ request, response }) => {
			const { auth } = request;
			if (auth) {
				dbg(`skipping cookie auth because auth record already set: ${auth.id}`);
				return;
			}
			/**
			* If the route is protected, check the auth
			*/
			const cookieRecordAuth = safeParseJson(request.cookies("pb_auth"));
			if (typeof cookieRecordAuth !== "object") {
				dbg(`invalid auth cookie found in cookie: ${cookieRecordAuth}`);
				response.cookie("pb_auth", "");
				return;
			}
			if (cookieRecordAuth?.token) try {
				const validAuthRecord = $app.findAuthRecordByToken(cookieRecordAuth.token);
				if (!validAuthRecord) {
					dbg(`invalid auth token found in cookie: ${cookieRecordAuth.token}`);
					response.cookie("pb_auth", "");
					return;
				}
				$apis.enrichRecord(request.event, validAuthRecord);
				request.auth = validAuthRecord;
				request.authToken = cookieRecordAuth.token;
			} catch (e) {
				dbg(`error fetching auth record: ${e}`);
			}
		},
		onExtendContextApi: ({ api }) => {
			const pb = () => api.pb();
			api.registerWithPassword = (email, password, options) => {
				api.createUser(email, password, options);
				const authData = api.signInWithPassword(email, password, options);
				return authData;
			};
			api.signInWithPassword = (email, password, options) => {
				const authData = pb().collection(options?.collection ?? "users").authWithPassword(email, password);
				api.signIn(authData);
				return authData;
			};
			api.signInAnonymously = (options) => {
				const { user, email, password } = api.createAnonymousUser();
				const authData = api.signInWithPassword(email, password, options);
				return authData;
			};
			api.signInWithOTP = (otpId, password, options) => {
				const authData = pb().collection(options?.collection ?? "users").authWithOTP(otpId, password.toString());
				api.signIn(authData);
				return authData;
			};
			api.requestOAuth2Login = (providerName, options) => {
				const methods = pb().collection(options?.collection ?? "users").listAuthMethods();
				const { providers } = methods.oauth2;
				const provider = providers.find((p) => p.name === providerName);
				if (!provider) throw new Error(`Provider ${providerName} not found`);
				const redirectUrl = `${$app.settings().meta.appURL}${options?.redirectPath ?? "/auth/oauth/confirm"}`;
				const authUrl = provider.authURL + redirectUrl;
				api.response.cookie(options?.cookieName ?? "pp_oauth_state", {
					...api.pick(provider, "name", "state", "codeChallenge", "codeVerifier"),
					redirectUrl
				});
				if (options?.autoRedirect ?? true) api.response.redirect(authUrl);
				return authUrl;
			};
			api.signInWithOAuth2 = (state, code, options, _storedProviderInfo) => {
				const storedProvider = _storedProviderInfo ?? api.request.cookies(options?.cookieName ?? "pp_oauth_state");
				if (!storedProvider) throw new Error("No stored provider info found");
				if (storedProvider.state !== state) throw new Error(`State parameters don't match.`);
				const authData = pb().collection(options?.collection ?? "users").authWithOAuth2Code(storedProvider.name, code, storedProvider.codeVerifier, storedProvider.redirectUrl, { emailVisibility: false });
				api.signIn(authData);
				return authData;
			};
			api.signOut = () => {
				api.response.cookie(`pb_auth`, "");
			};
			api.signIn = (authData) => {
				const { record, token } = authData;
				if (!record) throw new Error("No auth record found");
				dbg(`signing in with token and saving to pb_auth cookie: ${record.id} ${token}`);
				api.response.cookie(`pb_auth`, {
					token,
					record: toPlainObject(record)
				});
			};
		}
	};
};
var src_default = authPluginFactory;

module.exports = {
  plugins: [
    authPluginFactory
  ],
  debug: false
};
